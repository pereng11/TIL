# 22/11/17

- CSS-in-JS와 utility-first 방식을 모두 사용하고 싶다면?
	- twin 찾아볼 것

### HOC

- 클래스 컴포넌트가 가지고 있는 상태와 사이드 이펙트를 다루는 함수를 공유하기 위한 기법
	- loading / error / data 상태 
	- fetchData 함수 등
- 관례적으로 고차 컴포넌트를 반환하는 함수는 with로 시작하는 이름을 가진다.
- 재활용할 상태와 사이드 이펙트 함수를 가지고, 인수로 받은 컴포넌트를 children으로 반환하는 클래스 컴포넌트를 반환한다.

```jsx
// HOC를 반환하는 withFetch 고차함수
xport const withFetch = (Component) => {
  return class FetchDataHoc extends React.Component {
    static propTypes = {
      endpoint: PropTypes.string,
    };

    state = {
      loading: true,
      error: null,
      data: null,
    };
	// 래퍼 컴포넌트(HOC)는 loading / error / data 상태와 fetchData 함수, fetchData를 사용하기 위한 라이프 사이클 메서드를 가지고 side effect를 처리한다. 
    render() {
      const { loading, error, data } = this.state;
      const { children } = this.props;
      return (
        <Component loading={loading} error={error} data={data}>
          {children}
        </Component>
      );
    }

    componentDidMount() {
      this.fetchData();
    }

    async fetchData() {
      try {
        const { data } = await axios.get(this.props.endpoint);
        this.setState({
          loading: false,
          data,
        });
      } catch (error) {
        this.setState({
          loading: false,
          error,
        });
      }
    }
  };
};

// DataFetchDemo는 HOC로부터 상태를 props로 받아서 이용한다.

export const DataFetchDemo = withFetch(function DataFetchDemo({
  loading,
  error,
  data,
}) {
  if (loading) {
    return <span role="alert">Loading...</span>;
  }
  if (error) {
    return <div role="alert">{error.message}</div>;
  }
  return <div className={styles.container}>{data.name}</div>;
});

```

- 리액트의 대표적인 프로그래밍 기법이었으나 컴포넌트 레이어가 불필요하게 깊어지는 치명적인 문제가 있다.
	- 콜백 지옥과 비슷한 문제
	- hook이 등장한 가장 큰 이유

![[스크린샷 2022-11-17 오후 2.59.53.png]]

- HOC이 여러 번 중첩되는 경우 HOC + compose 패턴을 사용해 수평적으로 연결할 수 있다.
	- 하지만 이 방법도 근본적인 문제를 해결할 수 없다.
	- hook을 통해 문