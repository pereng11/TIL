# 22/11/11

## 리액트 정확하게 이해하기

### 왜 리스트 렌더링을 할 때 key에 index를 넣으면 안될까?

- 리액트에서 배열을 순회하면서 컴포넌트를 렌더링할 때, item이 되는 각 컴포넌트에 고유한 key를 주어야 한다는 이야기를 많이 봤다.
- 이때 배열의 index를 key로 사용하는 것을 최대한 자제하라는 단서가 늘 붙어있었는데, 대체 이유가 무엇인지 이번에 확실하게 이해해보기로 했다.

#### 상황을 정확하게 정리하기

다음의 내용을 나누어 생각해보고, 정확히 어느 지점에서 문제가 발생하는지 파악해보자.

- 우리는 리스트가 어떤 방식으로 렌더링 될 것이라고 예상하고 있을까?
- index를 key로 사용하면 어떻게 렌더링이 될까?

##### 우리가 기대하는 리스트 렌더링

- 우리가 기대하는 것은 **컴포넌트 단위**로 렌더링이 되는 것이다.
	-예를 들어, 


- 리액트는 reconciliation을 할 때 비교하는 두 요소의 타입과 key 속성을 우선적으로 비교한다.
- 이 때, 둘 중 하나라도 다를 경우 해당 요소를 새로 렌더링하고, 그렇지 않은 경우 자식 요소를 재귀적으로 탐색한다.
- 따라서 key를 고유하게 설정할 경우 리스트 내에서 순서가 바뀔 때 리스트 아이템 컴포넌트 단위로 리렌더링 한다.
- 그러나 index를 key로 사용할 경우 같은 위치에 존재하는 요소의 타입과 key가 이전과 동일하기 때문에 리스트 아이템 내부를 재귀적으로 탐색하여 리렌더링하게 된다.
- 다시 말해, 리스트 아이템을 하나의 컴포넌트 단위로 리렌더링하지 않고 컴포넌트를 쪼개서 부분적으로 렌더링하게 된다.
	- 컴포넌트 내부에서 props와 직접 연결된 세부 요소는 리렌더링 되지만 그렇지 않은 요소는 리렌더링되지 않는다.
	- 예를 들어, props에 의존하는 다른 형제 요소는 리렌더링 되더라도 비제어 컴포넌트로 사용하는 input은 리렌더링되지 않는다.
- 결론적으로, 