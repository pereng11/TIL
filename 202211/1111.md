# 22/11/11

## 리액트 정확하게 이해하기

### 왜 리스트 렌더링을 할 때 key에 index를 넣으면 안될까?

- 리액트에서 배열을 순회하면서 컴포넌트를 렌더링할 때, item이 되는 각 컴포넌트에 고유한 key를 주어야 한다는 이야기를 많이 봤다.
- 이때 배열의 index를 key로 사용하는 것을 최대한 자제하라는 단서가 늘 붙어있었는데, 대체 이유가 무엇인지 이번에 확실하게 이해해보기로 했다.

#### 상황을 정확하게 정리하기

다음의 내용을 나누어 생각해보고, 정확히 어느 지점에서 문제가 발생하는지 파악해보자.

- 우리는 리스트가 어떤 방식으로 렌더링 될 것이라고 예상하고 있을까?
- index를 key로 사용하면 어떻게 렌더링이 될까?

##### 우리가 기대하는 리스트 렌더링

- 우리가 기대하는 것은 **컴포넌트 단위**로 렌더링이 되는 것이다.
	-예를 들어, 


- 리액트는 reconciliation을 할 때 비교하는 두 요소의 타입과 key 속성을 우선적으로 비교한다.
- 이 때, 둘 중 하나라도 다를 경우 해당 요소를 새로 렌더링하고, 그렇지 않은 경우 자식 요소를 재귀적으로 탐색한다.
- 따라서 key를 고유하게 설정할 경우 리스트 내에서 순서가 바뀔 때 리스트 아이템 컴포넌트 단위로 리렌더링 한다.
- 그러나 index를 key로 사용할 경우 같은 위치에 존재하는 요소의 타입과 key가 이전과 동일하기 때문에 리스트 아이템 내부를 재귀적으로 탐색하여 리렌더링하게 된다.
- 다시 말해, 리스트 아이템을 하나의 컴포넌트 단위로 리렌더링하지 않고 컴포넌트를 쪼개서 부분적으로 렌더링하게 된다.
	- 컴포넌트 내부에서 props와 직접 연결된 세부 요소는 리렌더링 되지만 그렇지 않은 요소는 리렌더링되지 않는다.
	- 예를 들어, props에 의존하는 다른 형제 요소는 리렌더링 되더라도 비제어 컴포넌트로 사용하는 input은 리렌더링되지 않는다.
- 결론적으로, 


- 콜백 ref
	- 요소의 ref 속성에 콜백함수를 전달할 경우, 요소가 DOM에 렌더링되고나서 콜백함수가 호출된다
	- 그러나 요소의 크기와 같은 세부 프로퍼티에 접근할 때 제대로 된 값을 받아올 수 없는 경우가 있다.
		- img태그의 경우 이 시점에 제대로 된 높이 값을 받아올 수 없다
	- 따라서 그러한 목적을 위해서는 라이프 사이클 메서드를 사용해야 한다.

- jsonp
	- cors의 또다른 해결법? 찾아보자
	- 


- 리액트에서 알아야 할 사이드 이펙트
	- 비동기 처리
	- DOM요소 조작
	- 에러 핸들링
	- 이벤트 핸들링