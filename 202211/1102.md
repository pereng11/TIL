# 22/11/02

## Group Maker 유지보수

### 루트 컴포넌트 이벤트 핸들러 바인딩

#### 현재 상황

- 부분 reconciliation을 적용한 이후로, render함수가 호출될 때마다 DOM에 존재하지 않는 요소를 참조하는 이벤트 핸들러를 제거하고 새로운 이벤트 핸들러를 부착하도록 로직을 구성하였다.

```jsx
const updateEventHandlers = () => {
  const removeHandlers = [];

  handlersHolder.forEach(handlerInfo => {
    const { id, type, handler } = handlerInfo;

    if (document.querySelector(`[data-component-id="${id}"]`) || type === 'beforeunload') {
      window.addEventListener(type, handler);
    } else {
      window.removeEventListener(type, handler);
      removeHandlers.push(handlerInfo);
    }
  });

  handlersHolder = handlersHolder.filter(handlerInfo => !removeHandlers.includes(handlerInfo));
};
```

- 이때 루트 컴포넌트에서만 이벤트 핸들러 바인딩이 제대로 되지 않는 버그가 있었다. 프로젝트 마감 당시에는 시간이 부족해 일단 정상 동작하도록 땜빵코드를 작성하고, 언젠가 꼭 고치리라 마음먹었다.

```jsx
// App.js
setEvent() {
    return [
      {
        type: 'beforeunload',
        selector: 'window',
        handler: this.storeState.bind(this),
      },
    ];
  }

// eventHandler.js
// 조건문에 type === 'beforeunload'를 억지로 끼워넣은 코드
if (document.querySelector(`[data-component-id="${id}"]`) || type === 'beforeunload') 
```

#### 해결 과정

- 문제를 해결하기 위해 코드의 동작 흐름을 하나하나 쫓아가 보았다.(동작 - 동작을 명령하는 스크립트)
	1. 루트 컴포넌트 인스턴스 생성 - index.js
	2. 컴포넌트 id 생성 - component.js
	3. 이벤트 핸들러 임시 저장 - component.js
	4. 최초 상태를 불러오는 init함수 호출(비동기) - App.js
	5. 최초 렌더링 - index.js
	6. reconciliation - render.js
	7. **이벤트 핸들러 업데이트** - render.js
	8. init함수 내부에서 setState호출 - App.js
	9. 리렌더링 - component.js
	10. reconciliation - render.js
	11. 이벤트 핸들러 업데이트 - render.js

- 이벤트 핸들러가 바인딩되는 구체적인 과정은 다음과 같다.
	- 컴포넌트는 인스턴스가 생성되는 시점에 자신의 id를 생성하고, 해당 id와 이벤트 핸들러 정보를 묶어서 `handlersHolder` 배열에 임시 저장한다.
	- render함수가 호출될 때마다 reconciliation을 거쳐 DOM에 요소를 그린다. 요소가 DOM에 그려지고 난 뒤 `handlersHolder`를 순회하며 이벤트 핸들러를 업데이트 한다.
	- 더 이상 DOM에 존재하지 않는 id를 가지고 있는 핸들러는 삭제하고