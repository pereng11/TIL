# 22/11/01

## 팀 프로젝트

### Group Maker

#### 유지보수

- 처음부터 유지보수할 계획을 가지고 시작한 프로젝트임에도 한동안 손을 대지 못했다. 프로젝트 발표가 끝난 뒤 긴장이 조금 풀어지기도 했고, 이사 등 개인 사정이 겹쳐 미루게 되었다. 그래서 해야할 일, 하고싶은 일을 정리하여 오늘부터 본격적으로 작업을 시작하기로 하였다.

##### 비동기적인 상태 변경

- 1차 배포 전까지 해결해야하는 가장 중요한 이슈는 `유저 데이터와 관련된 상태와 DB를 어떻게 동기화할 것인가?` 이다. 현재 상태 변화 - 렌더링 - 이벤트 핸들러 관리가 하나로 묶여있기 때문에, 비동기로 상태를 변경하면 동작 흐름이 꼬여서 이전 데이터로 DB와 동기화를 하는 버그가 발생한다.

- 따라서, 상태가 비동기적으로 변경되는 경우 어떻게 안정적으로 처리할 수 있을지 고민해보고, 상태 변경을 다루는 라이브러리 코드를 수정하는 것으로 문제를 해결해보고자 한다.

## 리액트 수업

### 앱 개발에 필요한 과정

#### 빌드가 뭘까?

- 소프트웨어 분야에서 빌드(Build)는` 소스 코드 파일`을 컴퓨터나 휴대폰 등에서 `실행 가능한 파일`로 바꾸는 과정, 또는 그 결과물을 말한다.
- Javascript에서 빌드는 소스 코드를 원하는 배포 환경(브라우저 또는 Node.JS 등)에서 실행 가능한 파일로 바꾸는 과정을 말하며, 컴파일과 번들링, 최적화 과정을 포함한다.

- `Compile`: 소스 코드를 실행 환경이 이해할 수 있도록 다른 언어로 변환하는 것. 넓은 의미에서 Transpile을 포함한다.
	- `Transpile`: 언어를 비슷한 수준의 추상화를 가진 다른 언어로 변환하는 것. 예를 들면 ES6 코드를 ES5 코드로 변환하는 것.

#### Bundling

- 개발 단계에서 편의성과 유지보수성을 위해 모듈로 분할한 파일들을 다시 합치는 작업.

- 핵심 기능
	- Tree shaking
		- 최종 번들에서 사용하지 않는 코드를 걸러내주는 작업. 파일의 크기를 줄여서 속도를 향상시킨다.
	- Code spliting
		- 코드를 런타임에 동적으로 필요한 만큼만 불러올 수 있도록 적절하게 나누는 작업. code spliting 없이 번들링 된 코드는 파일의 크기가 비교적 크고, 사용하지 않는 페이지나 컴포넌트의 코드까지 일시에 불러와서 속도가 느리다. 따라서 런타임에 스크립트를 동적으로 제공하도록 파일을 분할하여 번들링하는 것이 성능에 좋다.
	- Source map
		- 번들링 된 파일과 원본 소스코드를 이어주는 소스맵 파일을 생성하는 작업. 번들링 과정에서 압축된 파일은 사람이 읽기 어렵기 때문에 디버깅이 어렵다. 소스맵 파일은 번들 파일에서 버그를 발생시킨 코드가 원본 소스 코드 중 어느 부분인지 매핑해주는 것으로 디버깅을 도와준다.


#### Webpack

- Module bundler. 모듈식으로 작성된 코드를 패키지로 묶어준다.
- 번들링 옵션을 유연하게 설정할 수 있다. 따라서 개발 환경 / 배포 환경 각각에 적절한 옵션을 설정함으로써 개발 단계에서 생산성을 높이고, 최적화된 파일로 앱을 배포할 수 있도록 도와준다.
- 컴파일 등 번들링 과정에 필요한 다양한 기능을 자체적으로 제공하며, Loader를 통해 서드파티 라이브러리와 결합하여 사용할 수도 있다.
- Development 환경에서는 개발의 편의성을 높여주는 devServer, sourcemap 등의 기능을 이용할 수 있다.
- Production 환경에서는 Tree Shaking, Code Spliting 등 파일 크기를 효과적으로 줄이고 로드 시간을 단축시킬 수 있는 기능을 이용할 수 있다.

##### 핵심 개념

- Entry
	- 의존성 트리의 진입점. Entry에 명시한 파일을 root로 하여 번들링한다.
	- 필요에 따라 여러 개의 진입점을 통해 번들링하는 것도 가능하다
- Output
	- 번들링 된 파일을 저장하는 방법. 진입점이 여럿이더라도 Output은 하나만 설정할 수 있다.
	- 파일 이름을 필수로 지정해야 한다.
		- `[name]`: 진입점 파일의 이름을 사용하기
		- `[contenthash]`: 임의의 해시를 파일 이름에 추가
- Loaders
	- 파일을  import / load하는 시점에 전처리를 해주는 기능
	- webpack은 기본적으로 js와 json파일만 해석할 수 있지만, loader를 이용해 다른 형식의 파일을 변환하여 처리할 수 있다.
	- `test`: 변환할 대상을 지정하는 속성
	- `use`: 변환을 수행할 loader를 지정하는 속성
- Plugins
	- loader가 할 수 없는 모든 것을 처리하는 기능
	- 번들링된 스크립트를 html에 자동으로 주입하기 등
- target
	- 배포 대상 환경에 대한 설정.
	- Browser, node.js 등의 배포 환경과 세부 옵션을 지정할 수 있다.

```javascript

const commonConfig = {
  target: ["browserslist"],
  resolve: {
    extensions: [".js", ".jsx", ".json", ".wasm"],
  },
  entry: {
    main: resolve("src/main.js"),
  },
  output: {
    path: resolve("public"),
    filename: "[name].bundle.js",
  },
  module: {
    rules: [babelLoader],
  },
  plugins: [
    new HtmlWebpackPlugin({
      template: './index.html',
    }),
    new MiniCssExtractPlugin({
      filename: 'dist/css/[name].[contenthash:8].css',
      chunkFilename: 'dist/css/[name].[contenthash:8].chunk.css',
    }),
  ],
};
```

##### 그 밖에 알게 된 것들

- 파일 이름에 hash를 붙이는 이유
	- html에 자동주입할 때 캐싱으로 최신 파일을 참조하지 못하는 경우를 방지하기 위해서

- 파일을 쪼개서 설정하는 이유
	- development / production 등 세부 환경을 유연하게 설정하기 위하여
		- 공통 코드를 분리한 뒤 객체 합성을 이용하여 환경에 따라 구성
	- 유지보수를 쉽게 하기 위하여
	- 일반적으로 plug-in, loader 등은 공통으로 하고 optimization 관련을 production에서 설정

- static으로 경로를 설정해주면 url경로로 정적파일을 제공할 수 있음

- 인라인에 직접 값을 할당하는 것보다 변수로 분리하여 사용하는 것이 좋은 이유
	- single curly brace로 통일성을 가져갈 수 있음
	- 유지보수에 유리함
