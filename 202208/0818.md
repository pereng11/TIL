# 22/08/18

## prototype의 메서드를 사용할 때 주의할 점
- 자신의 프로토타입 체인에 원하는 메서드가 있는지 확인할 것
	- 예) Object 빌트인 함수
		- `Object.create(null)`과 같이 `Object.prototype`을 상속받지 않는 객체 존재
		- `Object.hasOwn(객체, 키)`를 대신 사용하자. 
	
## 정적 메서드가 프로토타입 메서드보다 좋은 이유

### 가독성과 구현이 모두 좋음
- 프로토타입 메서드는 자신을 호출한 객체를 무조건 알아야 함
	- 내부 동작을 위해 `this`를 무조건 사용한다
- 정적 메서드는 자신을 호출하는 객체를 몰라도 된다
	- 내부 동작에서 `this`를 사용하지 않는다
```javascript
const obj = {score: 1}

// 프로토타입 메서드
// 프로토타입 체인이 예상과 다를 수 있고, 그에 따라 사용이 불가능할 수 있음
// 내부 동작 구현할 때 this가 꼬일 경우 굉장히 머리아파짐
// 인스턴스를 생성해야만 접근할 수 있음
obj.hasOwnProperty('score');

// 정적 메서드
// 생성자 함수로 바로 접근해서 사용함
// 구현에 this가 필요없음
// 직관적이고 가독성이 좋음
Object.hasOwn(obj, 'score');


```


### 객체지향 프로그래밍
- 상태를 프로퍼티로 사용
- 자바스크립트는 상태를 private하게 사용하기 어려움
	- 상태를 안전하게 유지하기 어려움
	- 프로토타입 체인 대신 스코프 체인을 이용해야 한다
		- 클로저를 무조건 사용해야 함


#### *Array의 메서드를 정적메서드로 제공하지 않는 이유*
- 다른 빌트인 객체와의 일관성을 유지하기 위해
	- Date, String 등 나머지 빌트인 객체들이 프로토타입 메서드를 사용하기 위해
```javascript

//앞부분은 객체지향형, 뒷부분은 함수형이다
[1,2,3].map(() => {});

```

### *프로토타입을 왜 쓰지?*
- 상속받기 위해

### *상속을 왜 하지?*
-재사용하기 위해

### **재사용하는 방법이 상속밖에 없나?**
- 스코프가 문제 없다면 굳이 생성자 함수와 연결짓지 말고 외부에 독립적으로 선언하는 것도 좋은 방법
- 객체지향을 너무 복잡하게 사용하지 마라
	- 상속 단계는 짧을 수록 좋다


생성자함수/클래스를 만드는 게 효율적인 경우
- 자료구조를 만들 때

상속
- 정확한 표현인가?
	- '확장'이라는 표현이 더 정확할 수 있음

*Array.prototype.length*
- 아마도 this를 사용해 length값을 산출해 반환하는 접근자 프로퍼티일 것이다

*Reflect()*
- for ... in의 함수버전

### 빌트인 전역 함수
- 자바스크립트 초창기에 나온 것
	- 가능하면 안 쓰는 게 좋음
		- 암묵적 형 변환 등
	- parseInt 제외하고 쓸 일 거의 없음


`1.toFixed()` 
- syntax error 발생
	- 소숫점 숫자가 올거라고 예상했는데 함수가 와서
	- 따옴표로 바꿔서 사용