# 2022/08/10

## 타입 변환

### 명시적 vs 암묵적

- 명시적 타입 변환(타입 캐스팅)
    - 개발자가 의도적으로 값의 타입을 변환하는 것
    - 문자열 변환
        - new 연산자 없이 String 생성자 함수 호출
        - Object.prototype.toString 메서드 사용
        - 문자열 연결 연산자 이용
    - 숫자 변환
        - new 연산자 없이 Number 생성자 함수 호출
        - parseInt, parseFloat 함수 사용(문자열만 변환 가능)
        - + 단항 산술 연산자 이용
        - * 산술 연산자 이용
    - 불리언 변환
        - new 연산자 없이 Boolean 생성자 함수 호출
        - 부정 논리 연산자 두 번 사용(`!!`)
- 암묵적 타입 변환(타입 강제 변환)
    - 표현식 평가 도중에 자바스크립트 엔진이 타입을 변환하는 것
        - 문맥에 맞지 않아 생기는 에러를 해결하기 위함
        - 어떻게 변할지 정확히 예측할 수 있어야 함
        - 코드를 읽는 과정과 연산하는 과정을 분리
            - 읽는 과정에서는 코드대로 읽고
            - 만약 타입에 문제가 생길 경우 연산 과정에서 강제 변환 후 연산
    - 문자열 변환
        - + 문자열 연결 연산자로 동작
        - 숫자 / 불리언 / null / undefined는 직관적으로 변환
        - 심벌은 변환 불가능
        - 객체
            - 상황마다 다름
    - 숫자 변환
        - 산술연산자 / 비교 연산자 / +단항 연산자로 동작
        - 특징
            - undefined → NaN
            - Symbol → 변환 불가능
            - `[]` (빈 배열) → 0
            - 나머지 객체 → NaN
    - 불리언 변환
        - Falsy
            - false
            - undefined
            - null
            - 0, -0
            - NaN
            - `''` (빈 문자열)
        - Truthy
            - Falsy 제외 나머지
        - 팁
            - `!!` 논리연산자로 강제 변환해서 불리언 값으로 활용 가능

### 특징

- 변환한 값은 기존 원시 값을 변경하지 않음
- 목적에 따라 선택하여 사용해야 함
    - 때로는 암묵적 변환이 가독성이 좋을 수 있음

### 단축 평가

표현식을 평가하는 도중에 결과가 확정되는 경우 나머지 평가 과정을 생략하는 것

- 논리 연산자
    - 논리곱 연산자(`&&`)
        - 좌항이 false라면 바로 좌항을 반환
        - 좌항이 true라면 우항을 반환
    - 논리합 연산자(`||`)
        - 좌항이 true라면 바로 좌항을 반환
        - 좌항이 false라면 우항을 반환
    - 꿀팁
        - 객체가 null / undefined 인지 검사 후에 프로퍼티를 참조하고 싶을 때
            
            ```jsx
            var elem = null
            
            var value = elem.name //TypeError: cannot read property 'value' of null
            var value = elem && elem.name; //null 할당
            ```
            
        - 함수 매개변수의 기본값을 할당하고 싶을 때
- 옵셔널 체이닝 연산자(`?.`)
    - 좌항이 null / undefined 이면 undefined 반환, 아니라면 프로퍼티 참조를 이어감
    - null / undefined만 확인하기 때문에 falsy를 확인하는 논리 연산자와 구분됨
- null 병합 연산자
    - 좌항이 null / undefined 이면 우항 반환
    - null / undefined만 확인하기 때문에 falsy를 확인하는 논리 연산자와 구분됨
    

## 객체 리터럴

### 타입으로서의 객체

- 다양한 타입의 값을 하나의 단위로 구성한 복합적 자료구조

### 객체

- 프로퍼티와 메서드로 구성된 집합체
    - 프로퍼티
        - key-value 쌍으로 구성된 객체의 구성 단위
            - key: 문자열 또는 심벌 사용 가능
            - value: 모든 데이터 타입 가능
        - 메서드 / 메서드 아닌 프로퍼티
            - 메서드 아닌 프로퍼티
                - 객체의 상태를 나타내는 값
            - 메서드
                - 객체의 상태를 참조하고 조작하는 동작
    - 메서드
        - 함수를 값으로 가지는 프로퍼티
- 프로퍼티 접근법
    
    프로퍼티 키가 네이밍 규칙을 준수한 경우 아래 두 가지 표기법을 모두 사용할 수 있다
    
    - 마침표 표기법
        - `객체.키` 로 접근
    - 대괄호 표기법
        - `객체[키]` 로 접근
            - 따옴표로 감싼 경우
                - 문자열로 인식해서 해당 문자열을 키로 가지는 프로퍼티에 접근
                - 네이밍 규칙을 준수하지 않은 문자열도 접근 가능
            - 따옴표로 감싸지 않은 경우
                - 식별자로 인식
                    - 식별자로 가져온 값을 키로 가지는 프로퍼티에 접근
                    - 식별자가 존재하지 않을 경우 에러 발생
        
        ```jsx
        var person = {
        	name: 'son'
        }
        
        console.log(person.name) // son
        
        // 존재하지 않는 프로퍼티에 접근했을 때,
        // 식별자로 접근한 경우 에러를, 문자열로 접근했을 때 undefined를 반환
        console.log(person[name]) // ReferenceError: name is not defined
        console.log(person.age) // undefined
        ```
        
- ES6 확장기능
    - 프로퍼티 축약 표현
        - 사용하고자 하는 프로퍼티 키와 변수명이 같을 경우 한 번에 쓸 수 있음
        
        ```jsx
        const son = 15;
        const tong = 20;
        
        const obj = {
        	son,
        	tong
        }
        
        console.log(obj);  // { son: 15, tong: 20 }
        ```
        
    - 계산된 프로퍼티 이름
        - 객체리터럴 내부의 키에 표현식을 사용 가능
        
        ```jsx
        var prefix = 'prop';
        var i = 0;
        
        const obj = {
        	[`${prefix} + '-' + ${i}`]: i,
        	[`${prefix} + '-' + ${i}`]: i,
        	[`${prefix} + '-' + ${i}`]: i,
        };
        
        console.log(obj); // { 'prop - 1': 1, 'prop - 2': 2, 'prop - 3': 3 }
        ```
        
    - 메서드 축약 표현
        - 프로퍼티에 값으로 할당한 함수와 다르게 동작함(this 바인딩?)
        
        ```jsx
        const obj = {
        	name: 'son',
        	sayHi(){
        		console.log(`Hi, I'm ${name}.`);
        	}
        }
        ```