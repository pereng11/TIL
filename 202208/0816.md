# 22/08/16

## 조각 지식

모든 변수는 객체가 된다?
- key: value로 존재하기 때문

함수 호출문은 제어문이다
- 코드 실행 순서를 바꿔줌
	- 더 위에 씌어진 코드를 실행하게 함

## 함수 정의 vs 함수 평가
- 정의
		- 런타임 이전에 실행
		- 토큰화 된 소스코드를 저장
	- 평가
		- 함수 호출 시점에 진행
			- 함수가 정말 실행될 지 알 수 없기 때문에
			- 메모리/시간을 낭비하지 않기 위해
		- 함수 스코프 생성



모든 함수는 자신의 상위 스코프를 알아야 함
- 언제 알지? 
	- 함수가 정의가 평가되는 시점
	- 내부 슬롯`[[Environment]]`에 저장된다
		- -> `[[Environment]]`가 스코프체인을 알고있다
- 언제 잊어버리지?
	- 함수가 메모리에서 해제되는 시점

Deep Dive 198쪽 13-9번 예제를 완벽하게 이해하자


AST(Abstract Syntax Tree)
- 파싱의 결과로 나온 토큰을 트리 형태로 만든 것
- 코드를 실행하기 위한 진짜 재료

[AST Explorer]('https://astexplorer.com')


CSS ruleset

실행 환경에 따른 API차이
- ECMAScript에 상세 구현 사항이 정의되지 않은 경우, 자바스크립트 엔진을 만드는 회사가 스펙을 각자 알아서 함
	- 브라우저와 node.js(bun, deno 등)의 차이
- 예시
	- console.log의 차이


순회와 열거의 차이
- 순회: 순서가 중요
	- 배열은 인덱스가 다르면 다른 것
		- `인덱스`
- 열거: 순서가 중요하지 않음
	- 객체는 프로퍼티 순서가 달라도 같은 것
		- 프로퍼티 `키`
	- `in`키워드로 접근할 수 없음


유사배열객체는 설계 미스다?
- 유사배열객체의 존재 의미
	- 배열에 없는 메서드를 직접 만들어서 사용할 수 있음
	- 하지만 굳이 그렇게까지 만들어서 쓸 메서드가 없음
	- ES6의 rest parameter로 더 깔끔하게 대체 가능
- 기존에 존재하는 유사배열 객체는 배열로 받아서 사용하자
	- `[...document.querySelectorAll()]` 와 같이 rest parameter를 사용


`this`에는 할당이 불가능
- 그래서 바인딩을 해야함
	- 바인딩: 식별자와 값을 묶는 것


생성자 함수의 안티 패턴
- this에 메서드를 바로 묶는 것
```javascript
function Foo(a){
	this.a = a;

	// 인스턴스가 생성될 때마다 함께 생성되어 공간/시간 모두 낭비
	this.f = function(){...}

	// 해결법 1. 생성자 함수 외부에 정의하여 가져다 쓰기

	// 해결법 2. prototype의 메서드로 생성하기
	
}
```

![[prototype.png]]
- 
- 해결법 1과 2의 차이
	- 위계가 있느냐
		- prototype은 위계가 있음
	- private 변수를 사용할 수 있는가
		- prototype은 사용 가능



prototype이 어려운 이유
- 비슷한 애들이 많아서

생성자 함수의 prototype === 생성자 함수가 생성하는 인스턴스가 가리키는 prototype


`this`
- 함수 호출 방식에 따라 결정
	- 일반 호출 -> 전역 객체
	- 메서드 호출 -> 메서드를 호출한 객체
		- 생성자함수 호출 -> 생성된 인스턴스의 객체
			- 인스턴스의 this는 암묵적으로 생성된 '객체'이기 때문



**생성자 함수의 this는 인스턴스를 가리킨다**
- 생성자 함수에서 암묵적으로 빈 객체 생성
- this에 빈 객체 바인딩
- this를 반환



**식별자는 scope-chain에서, 프로퍼티는 prototype-chain에서 찾는다**
- => **scope는 식별자를 위한 공간, prototype은 객체의 property를 위한 공간**
- 프로퍼티는 문법적으로 식별자가 아니다
	- 식별자 명명규칙을 준수하지 않아도 된다

