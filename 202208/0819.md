# 22/08/19

## Ascii
- 문자를 컴퓨터가 이해할 수 있는 이진수로 변환하는 인코딩 방법 중 하나
- 영어와 숫자와 일부 특수기호를 담은 테이블
- 각 문자를 1Byte(=== 8bit)로 표현

## Unicode
- 세계 각국의 언어와 이모지까지 담은 인코딩/디코딩 테이블
	- 한정된 문자만 담은 ASCII의 한계를 극복하기 위해 탄생
	- ASCII에 대한 하위 호환 보장

### 가변 인코딩
- 인코딩에 필요한 만큼만 데이터를 사용하는 것
	- 알파벳은 1바이트 사용, 한글은 3바이트 사용
		- 
- 각 바이트의 앞자리는 단위를 나타내는 약속어로 사용
	- 한 번에 몇 바이트를 읽어야 제대로 읽을 수 있는지 알려준다
		
	 ![[Pasted image 20220819191734.png]]

---
---
## this

### 사용 목적
- 함수의 호출 주체를 동적으로 결정하기 위해
	- 특정 객체를 직접 가리킬 경우 해당 객체에 완전하게 종속되기 때문에
 

```javascript
const circle = {
	radius: 5,
	getDiameter(){
		return circle.radius * 2;
	}
}

const o = {
	radius: 2,
	foo: circle.getDiameter
}

o.getDiameter(); // 10 반환
// 명시적으로 circle을 가리키기 때문에 어떤 객체에서 사용해도 같은 값 반환
// 유연하게 사용하기 어려움

```

### 모든 함수는 정의되는 시점에서는 어떻게 동작할 지 알 수 없다
- 일반 함수, 메서드, 생성자 함수(화살표 함수, 축약 메서드 제외) 모두 가능
- ES6에서는 함수의 목적을 고려하여 동작에 제약조건을 걸었다
	- constrictor 내부 메서드를 가지지 않는 함수(화살표함수, 메서드 축약) 


### this의 불일치
- 중첩 함수에서 외부 함수와 내부 함수가 가리키는 this가 다른 것
	- 함수의 동작을 예측하기 어려움

#### 해결 방법
1. this를 새로운 변수에 할당
	1. 단순하지만 효과적. 하지만 우아하지 않음
2. apply / call / bind 메서드 사용
	1. apply, call과 bind의 차이
		1. 함수의 본질적인 목적
			- apply/call: 자신을 호출한 함수 실행
			- bind: 자신을 호출한 함수에 새로운 this 바인딩
		2. 반환 값
			- apply, call: 함수를 실행한 반환 값
			- bind: 함수(this만 달라짐) 자체
	2. apply와 call의 차이
		- 인수의 형태
			- ㅊ미값들의 나열
1. 화살표 함수 사용
	- 화살표 함수는 자신의 this를 가지지 않음
	- 따라서 외부 스코프에서 this 식별자를 찾게되고, 자연스럽게 외부 함수의 this를 참조
	- 가장 깔끔한 방법

```javascript
var value = 1;

const obj = {
	value: 100,
	foo(){
		setTimeOut(function(){
			console.log(this.value);
		}, 100);
	}
}

obj.foo(); // 1

// 해결방법 1

const obj = {
	value: 100,
	foo(){
		// foo의 this를 that이 기억
		// setTimeOut 콜백함수의 this 대신 foo의 this를 참조하도록 함
		const that = this;
		setTimeOut(function(){
			console.log(that.value);
		}, 100);
	}
}

obj.foo() // 100
// foo함수가 메서드로 호출 -> foo의 this는 obj에 바인딩 -> foo의 this를 가리키는 that변수또한 obj를 가리킴 -> that.value === obj.value === 100

// 해결방법 2

const obj = {
	value: 100,
	foo(){
	// bind 함수를 사용해 명시적으로 this 전달. 
		setTimeOut(function(){
			console.log(this.value);
		}.bind(this), 100);
	}
}

obj.foo() // 100
// 마찬가지로 메서드로 호출되었기 때문에 this는 obj를 가리키고 있음

// 해결방법 3

const obj = {
	value: 100,
	foo(){
	// 화살표 함수를 사용
		setTimeOut(() => {
			console.log(this.value);
		}, 100);
	}
}

obj.foo() // 100
// 화살표함수는 자신의 this를 가지지 않음 -> 외부 스코프의 this를 참조 -> foo의 this를 참조

```



내부함수와 콜백함수의 차이
- 외부스코프
	- 내부함수: 외부함수
	- 콜백함수: 해당 함수가 정의된 곳에 의해 결정
- 로직의 위치
	- 고차함수(외부함수)에서 사용할 로직을 내부에서 직접 정의하느냐, 외부에서 가져오느냐


---


## scope

객체리터럴의 중괄호와 블록문의 중괄호를 헷갈리지 말자

- 렉시컬 스코프의 핵심
	- 상위 스코프를 어떻게 결정하느냐
		- 함수 정의 시점

- 중첩함수를 만드는 이유
	- 외부함수에서만 사용하려고
	- 가독성을 높이기 위해
		- 함수 이름으로 복잡한 로직의 역할을 쉽게 알아볼 수 있음



주석의 문제점
- 코드의 가독성이 떨어진다는 반증
- 유지보수가 어려움
	- 코드와 주석을 함께 고쳐야 하기 때문




---
---


## 함수

### Parameter / Argument
- argument는 argument를 사용하는 함수의 바깥에 존재한다




setTimeOut의 콜백 함수
- 브라우저가 호출한다
	- 호출방법 알 수 없음
	- 결과로 미루어 보면 일반함수로 호출하는 것 같아 보임
- setTimeOut은 딜레이 시간을 설정하고 콜백함수를 브라우저에 넘겨주는 역할까지만 함


함수 호출
- 함수 식별자가 가지고 있던 `함수 몸체의 코드를 담은 문자열`을 `평가`하는 것

### 함수 객체

함수 객체는 함수 정의를 평가할 때 생성
- 함수 선언문 -> 소스코드 평가 단계
- 나머지 -> 소스코드 실행 단계(런타임)

**함수 객체 !== 함수 몸체**
- 함수 객체 생성 시에는 함수 몸체 내부의 코드를 보지 않는다

#### 함수 정의가 평가될 때 생성되는 것들
- 상위 스코프 결정
	- `[[Environment]]]` 내부 슬롯
- 함수 객체 프로퍼티
	- arguments
	- name
	- length
	- prototype(constructor 함수만 해당)
- 내부 슬롯 생성
	- `[[prototype]]`
	- `[[environment]]`(함수 객체에만 있음)
	- `[[FormalParameters]]`(함수 객체에만 있음)
- 내부 메서드 생성
	- `[[call]]`
	- `[[construct]]`(constructor함수만 가짐)
- 함수 몸체(문자열)
	- **이때 문자열의 내용까지 파악하지 않음**
	- 함수를 호출하면 그 때 파싱
- 객체의 프로퍼티로 할당한 함수도 마찬가지



메서드
- 통상적 의미
	- 객체의 프로퍼티로 할당한 함수
- ES6기준
	- 축약표현으로 객체에 할당한 메서드'만' 메서드


## 호이스팅

let / const 의 호이스팅
- 런타임 이전
	- 렉시컬환경의 환경 레코드에 식별자 등록
		- 이때 해당 메모리 공간에 최초로 어떤 값이 들어가는가
			- 알수 없음
				- 아마도? 심볼과 같은 고정적이고 유니크한 상수
				- 해당 값을 만나면 uninitialized Error 반환
- 재할당 금지 원리
	- const라는 토큰을 만났을 때 어떻게 동작하는지에대한 내부 로직이 존재할 것



**에러가 발생했다는 것 === 일단 접근했다는 것?**



---
---

## 실행 컨텍스트

### 소스코드의 타입

#### 타입을 구분하는 이유
- 소스코드의 타입에 따라 실행 컨텍스트의 생성 과정과 관리 내용이 달라지기 때문에

#### 종류
- 전역 코드
	- 
- 함수 코드
- 모듈 코드
- eval 코드

### ES5 이전 상황

#### **전역 스코프 === 전역 객체**




### 용어 구체화
- 런타임 이전 => (전역) 소스코드의 평가 단계
- 런타임 => (전역) 소스코드의 실행 단계
- 스코프 => 실행 컨텍스트의 렉시컬 환경의 환경레코드

### 선언문의 역할
- 식별자를 만드는 것
- 식별자를 실행 컨텍스트에 등록하는 것


### 소스코드의 평가와 실행 단계를 분리한 이유
- 코드를 효율적이고 안정적으로 실행하기 위해
	- 코드 실행에 필요한 기본 정보들을 미리 생성
		- 현재 렉시컬 환경과 식별자
		- 외부 렉시컬 환경에 대한 참조 등

## 실행 컨텍스트

### 역할
- 소스코드를 실행하는 데 필요한 환경을 제공하고 실행 결과를 실제로 관리하는 영역
- 식별자를 등록하고 관리하는 스코프와 코드 실행 순서 관리를 구현한 내부 메커니즘

### 구성 요소
- 렉시컬 환경(Lexical Environment)
	- 환경 레코드
		- 객체 환경 레코드
		- 선언적 환경 레코드
		- `[[GlobalThisValue]]`
	- 외부 렉시컬 환경 참조
- Variable Environment
	- *최초에 렉시컬 환경과 동일한 렉시컬 환경을 참조*
	- *이후 특정한 상황을 만나면 새로운 렉시컬 환경을 생성*

