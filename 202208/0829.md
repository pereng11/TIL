# 22/08/29

## 브라우저 렌더링

### HTTP

#### HTTP1, 1.1

- http1
	- 매 요청마다 연결을 닫음
	- TCP 사용
	- 헤더가 무거움
		- 중복과 관계 없이 요청에 대한 메타정보를 매번 보내야 함
- http1.1
	- 하나의 연결로 다수의 요청 가능
	- 1과 마찬가지로 헤더가 무거움
- http2
	- 멀티플렉싱 지원
	- 하나의 연결에 여러 요청을 처리할 수 있음
		- 순서에 상관 없이 한꺼번에 요청 가능
		- 반환 시 내부적으로 중요도를 매김
		- 아직 요청하지 않은 데이터도 필요하다면 서버에서 알아서 보내줌
		- **HTML 로드/파싱 과정에 한정지어 생각하지 말 것!!!**
- http3
	- TCP 대신 QUIC이라는 방법을 사용해서 속도가 빠름
		- UDP 방식의 하나
		- TCP의 신뢰성과 UDP의 속도를 결합

### 주소창에 네이버를 입력하면?

1. 프로토콜과 도메인을 DNS로 보내서 IP주소로 변환
2. IP주소에 path 등을 더한 URI를 이용해 네이버 서버에 자원 요청
3. 서버가 클라이언트에 데이터 전송
	1. 도메인 뒤에 path가 정해지지 않은 경우 index.html을 전송
4. 이진수형태로 넘어온 데이터를 문자열로 변환
	1. http 응답 헤더에 디코딩 방식이 들어있음
		1. html의 경우, meta태그에 담긴 charset 속성을 기준으로 결정
	2. 파일 확장자마다 기본 방식이 다름
5. 문자열을 파싱하여 DOM / CSSOM / AST를 생성하고 실행하여 렌더링


### 렌더링 과정

- HTML 코드를 순차적으로 파싱&실행
- link / script 태그를 만날 경우
	- DOM 파싱을 멈추고 해당 소스를 로드하고 파싱&실행
	- CSS
		- CSSOM 트리 생성
	- JS
		- async / defer 속성을 추가하면 DOM 파싱과 스크립트 로드를 병렬적으로 진행
- DOM과 CSSOM을 합쳐서 Render Tree 생성
	- HTML 파싱이 끝나지 않아도 바로바로 진행
- Render Tree를 기준으로 레이아웃 / 페인트 / 컴포지션 단계를 거쳐 화면에 렌더링
	- 이후 Render Tree가 변화할 때마다 리플로우 / 리페인트 등이 발생하며 재렌더링
		- DOM요소 조작, 스타일 변동 등


#### async / defer
- async 
	- 실행 순서가 보장되지 않음
	- Blocking이 일어남
	- font를 불러올 때 유용함
		- 나중에 불러오면 화면이 깜빡이기 때문에 최대한 빨리 불러오는 것이 좋음
			- font가 바뀌면 새로 그려야 하기 때문
- defer
	- module을 쓰면 자동으로 적용됨
	- DOM 파싱을 blocking하지 않기 때문에 LCP 속도가 빠르다


**CSSOM은 DOM과 독립적으로 생성이 된다**
- CSS 파일을 파싱할 때
	- 스타일시트에 작성된 룰셋을 기준으로 트리를 만든다
- 렌더트리로 합쳐질 때
	- 선택자와 일치하는 노드에 스타일을 적용한다
	- CSS에 명시되지 않은 부분들에 대해 cascading을 적용한다

**리플로우를 발생시키는 메서드를 조심할 것**
- DOM을 조작할 때는 리플로우를 발생시키는지 확인할 것

**최적화는 문제가 발생한 이후에 할 것**
- 일단 가독성 중심으로 코딩할 것
- 성능 문제의 원인은 대부분 이미지