# 22/08/22

## 실행 컨텍스트

### 

소스코드의 타입

#### 

타입을 구분하는 이유

-   소스코드의 타입에 따라 실행 컨텍스트의 생성 과정과 관리 내용이 달라지기 때문에

#### 

종류

-   전역 코드
    -   전역에 존재하는 코드. 함수의 내부 코드는 포함하지 않음.
-   함수 코드
    -   함수 내부의 코드(함수 몸체).
    -   내부 함수의 코드는 포함하지 않음.
    -   클래스도 함수의 일종.
-   모듈 코드
    -   모듈 내부에 존재하는 코드. 함수의 내부 코드는 포함하지 않음
-   eval 코드
    -   eval함수에 인수로 전달되어 실행되는 코드

### 

용어 구체화

-   런타임 이전 => (전역) 소스코드의 평가 단계
-   런타임 => (전역) 소스코드의 실행 단계
-   스코프 => 실행 컨텍스트의 렉시컬 환경의 환경레코드

**전역 코드뿐만 아니라 함수코드에 대해서도 평가 단계와 실행 단계가 분리된다**

### 

소스코드의 평가와 실행 단계를 분리한 이유

-   코드를 효율적이고 안정적으로 실행하기 위해
    -   코드 실행에 필요한 기본 정보들을 미리 생성
        -   현재 렉시컬 환경과 식별자
            -   함수 선언문의 경우 식별자 + 함수 객체 공통으로 적용되는 기본 속성(함수 호이스팅)
        -   외부 렉시컬 환경에 대한 참조 등

### 

실행 컨텍스트의 역할

-   소스코드를 실행하는 데 필요한 환경을 제공하고 실행 결과를 실제로 관리
-   식별자를 등록하고 관리하는 스코프와 코드 실행 순서 관리를 구현한 내부 메커니즘

#### 

선언문의 역할

-   식별자를 만드는 것
-   식별자를 실행 컨텍스트에 등록하는 것

### 

실행 컨텍스트 스택(콜 스택)

-   코드의 실행 순서를 관리하는 자료구조
-   소스코드 단위 별로 생성되는 실행 컨텍스트의 실행 순서를 관리
-   스택 자료구조를 사용하기 때문에 가장 마지막에 들어온 실행 컨텍스트를 가장 우선적으로 실행

### 

내부 구조

-   실행 컨텍스트
    -   랙시컬 환경
        -   환경 레코드
            -   전역 / 함수 / 블록 환경 레코
        -   외부 렉시컬 환경 참조
    -   -   _Variable Environment_
        -   최초에 렉시컬 환경과 동일한 렉시컬 환경을 참조
        -   이후 특정한 상황을 만나면 새로운 렉시컬 환경을 생성

### 

렉시컬 환경(Lexical Environment)

**스코프를 구분하여 식별자를 관리하는 저장소 ===** 렉시컬 스코프의 실체**  
**실행 컨텍스트와 독립적으로 존재한다. 실행 컨텍스트는 렉시컬 환경을 가리키는 참조값을 가질 뿐**  
- 따라서 실행 컨텍스트의 생명주기가 끝나도 렉시컬 환경은 살아있을 수 있음 -> 클로저로 연결

-   환경 레코드
    -   전역 환경 레코드  
        **ES6 이전에는 전역 객체 === 전역 스코프였으나, 현재는 전역 객체 ⊂ 전역 스코프로 생각해야 함**
        -   객체 환경 레코드
            -   `bindingObject`를 키로 전역 객체와 연결
                -   _바로 window 객체와 연결하지 않는 이유는?_
                    -   서로 다른 실행 환경(브라우저, Node.js 등)에 대해 동일한 인터페이스를 제공하기 위해
            -   `var` 키워드로 선언한 변수와 함수 선언문으로 선언한 함수를 전역객체의 프로퍼티로 등록
                -   _`var`로 선언한 식별자를 undefined로 자동 초기화하는 이유는?_
                    -   전역 객체에 등록해야 하고, 객체의 프로퍼티는 키-값이 쌍으로 존재해야 하기 때문이 아닐까?
        -   선언적 환경 레코드
            -   `let / const` 키워드로 선언한 식별자 관리
        -   `[[GlobalThisValue]]`
            -   런타임 환경에 따른 전역 객체를 가리킴
                -   브라우저: `window`
                -   Node.js: `global`
    -   함수 환경 레코드
        -   함수 환경 레코드
            -   매개 변수, arguments, 지역 변수와 중첩함수를 등록하고 관리
            -   선언 키워드와 관계 없이 모든 변수를 한 공간에서 관리
                -   _객체의 프로퍼티로 등록되는 것과 아닌 것을 구분할 필요가 없기 때문에?_
        -   ThisValue
            -   함수 호출 방법에 따라 결정된 객체 참조
            -   **화살표 함수로 선언된 함수는 이 과정을 거치지 않는다**
    -   (블록)환경 레코드
        -   선언적 환경 레코드
            -   var는 함수 레벨 스코프를 따르기 때문에 자동으로 상위 스코프에 등록
-   외부 렉시컬 환경 참조
    -   현재 평가중인 소스코드를 포함하는 외부 소스코드의 렉시컬 환경(상위 스코프)을 가리킴
    -   해당 참조를 통해 스코프 체인 형성
    -   **함수의 경우, 해당 참조값을 함수 객체의 `[[Environment]]` 내부 슬롯에 저장한다**
        -   이를 통해 실행 컨텍스트가 종료된 후에도 상위 렉시컬 환경을 참조할 수 있음
        -   클로저 생성의 핵심

### 

코드 평가 순서

1.  실행 컨텍스트 생성
2.  렉시컬 환경 생성
    1.  환경 레코드 생성
        -   전역 환경 레코드
            -   객체 환경 레코드
            -   선언적 환경 레코드
            -   GlobalThisValue
        -   함수 환경 레코드
            -   함수 환경 레코드
            -   ThisValue
        -   (블록)환경 레코드
            -   선언적 환경 레코드
    2.  this 바인딩
    3.  외부 렉시컬 환경에 대한 참조 결정

**코드 블록(블록 레벨 스코프)은 실행 컨텍스트를 생성하지 않는다**

-   기존 실행 컨텍스트에서 블록 렉시컬 환경만 새롭게 생성한다
-   외부 렉시컬 환경 참조로 이전 렉시컬 환경을 참조한다
-   `ThisValue`를 가지지 않는다
    -   새로운 this를 가질 이유가 없기 때문에

### 

식별자 결정

-   코드 실행을 위하여 어떤 식별자를 참조할지 결정하는 것
-   현재 실행 중인 실행 컨텍스트부터 스코프 체인을 이용해 식별자 검색
    -   같은 이름을 가진 식별자의 경우, 가장 가까운 식별자를 선택
    -   스코프체인을 이용해 선언되지 않은 식별자 검색
-   전역 렉시컬 환경에서도 찾지 못할 경우 참조 에러(`Refference Error`) 반환
-   **`this`**
    -   `this`도 식별자이므로, 현재 실행 중인 실행 컨텍스트의 렉시컬 환경에 this가 존재하지 않는 경우, 스코프 체인을 이용해 상위 스코프에서 this를 참조한다
        -   화살표 함수는 this 바인딩 과정을 거치지 않기 때문에 자신의 스코프에 this를 가지지 않는다
            -   따라서 스코프 체인을 통해 상위 스코프의 this를 참조하게 되고, 자연스럽게 외부 함수와 같은 this를 참조하게 된다.
        -   블록 레벨 스코프 또한 자신의 렉시컬 환경에 ThisValue를 가지지 않기 때문에, 자연스럽게 블록문이 실행되는 환경의 this를 참조하게 된다