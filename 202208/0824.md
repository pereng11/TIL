# 22/08/24

## 클래스

*클래스는 프로토타입의 문법적 설탕인가?*
- 내부 동작이 다르기 때문에 문법적 설탕으로 보기 어려움

### 클래스를 사용해야 하는 이유

#### **클래스 대신 생성자 함수를 사용할 이유가 없다**

1. 생성자 함수로는 불가능한 기능을 제공한다
	1. private 프로퍼티 지원
	2. new 키워드 검사
	3. extends / super 키워드 제공
2. 생성자 함수보다 엄격하다
	1. strict mode 자동 적용
	2. 호이스팅이 발생하지 않는 것처럼 동작(let / const처럼)
3. 생성자 함수보다 사용하기 쉽다
	1. 가독성이 좋음
		1. 메서드 선언 문법이 간결함
		2. 생성자함수보다 구조가 직관적

### 클래스 생성 과정

클래스 내부 코드는 순차적으로 실행되지 않는다?
- constructor가 최상단에 존재하지 않아도 된다
- 하지만 가독성을 위해 순서를 지키는 게 좋음

#### 클래스 정의 평가
 - 정의되는 시점에서는 객체로서 평가됨
	 - 클래스를 호출하지 않았음에도 내부 프로퍼티가 등록됨
 - 평가 과정에서 클래스 식별자에 생성자 함수 객체 바인딩
	 - 함수 객체의 코드가 되는 것들
		 - constructor 내부 코드
		 - 클래스 필드 중 인스턴스의 프로퍼티
 - 따라서 평가 이후에는 함수로 인식됨
	 - 클래스 식별자가 함수를 참조하기 때문
- 참고자료
	- [ECMAScript class 명세](https://tc39.es/ecma262/multipage/ecmascript-language-functions-and-classes.html#sec-static-semantics-constructormethod)

#### 언제 사용하는 것이 좋을까?

- 클래스를 사용하는 것이 효율적인 경우
	- 똑같은 인스턴스를 대량 생산해야 하는 경우
		- 자료구조 구현

- *클래스를 어플리케이션에 적용하는 것이 쉽지 않다*
	- this가 꼬이기 때문이라는데, 왜?


### 상속에 의한 클래스 확장

#### `super`
 - super를 꼭 constructor 최상단에서 선언해야하는 이유
	- 인스턴스가 가질 this를 최상단 super 클래스가 생성하기 때문
	- 최상단 super 클래스부터 체인을 따라 순서대로 this를 초기화하며 받아옴



클래스와 인스턴스가 각각의 프로토타입 체인을 가짐


### 프로토타입 메서드와 정적 메서드

#### 선택 기준
- 프로토타입 메서드
	- 인스턴스의 값을 참조해야 하는 경우(this를 사용해야 하는 경우)
- 정적 메서드
	- 인스턴스를 생성하지 않고도 사용하고 싶은 경우

