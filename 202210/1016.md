# 22/10/16

## 오늘 고민한 것

### 큰 그림 보기 vs 하나하나 차근차근 하기

- 어떤 기능을 만들 때, 처음부터 너무 많은 걸 생각하는 버릇을 고치려고 노력하는 중이다. 확장성이나 예외상황 등을 고민하다 핵심에서 벗어나 옆길로 새는 일이 많았기 때문이다.
- 그런데 단순하게 생각해서 한 번에 하나만 하다보니 설계 방향이 잘못되어 중간에 갈아엎어야 하는 상황이 또 발생하기도 한다. 
- 결국 모든 건 *적당히* 하라는 것 같은데...정말 감 잡기가 너무 어렵다

### 구조를 해치지 않으면서 예외사항 처리하기

#### 라이브러리 이벤트 핸들러 함수

- 컴포넌트에서 이벤트 핸들러를 받아올 때 이벤트 타입, CSS 선택자, 핸들러 함수 3가지 정보를 받아온다. 기존에는 selector를 이용하여 라이브러리 내부에서 early return을 해주었는데, 이벤트 타깃이 window인 경우 matches나 closest함수를 사용할 수 없어 오류가 발생했다. 
- window는 예외상황이라고 보고, 조건문에 `selector === 'window'`인 경우를 추가했는데, 이게 깔끔한 처리인지, 땜빵 코드인지 모르겠다..

### 지난 번 만들었던 CBD 라이브러리의 컴포넌트가 지역상태를 가질 수 있도록 하기

#### 시작하기 전

- 내가 생각하는 전역 상태 / 지역 상태는 다음과 같다
	- 전역 상태: 컴포넌트 외부에서 생성되고, props으로 내려줄 필요 없이 필요한 곳에서 바로 import해서 사용할 수 있는 상태
	- 지역 상태: 컴포넌트 내부에서 직접 생성하며, 필요한 하위 컴포넌트에 props로 건네주는 상태
- 위 관점에서 보면 기존에 만들었던 라이브러리는 전역 상태를 사용할 수 없고, 루트 컴포넌트만이 지역 상태를 가질 수 있었다.  상태가 컴포넌트 내부에서 생성되며, 루트 컴포넌트를 제외한 나머지 컴포넌트는 재렌더링이 될 때 상태를 유지할 수 없었기 때문이다.
- 어플리케이션의 규모가 커지면서 루트컴포넌트 한 곳에서 모든 상태를 관리하는 것이 불가능해졌기 때문에 모든 컴포넌트에서 지역상태를 사용할 수 있도록 할 필요가 생겼다
- 지금 생각나는 건 크게 두 가지인데, 아직 구체적인 방법은 더 고민해봐야 할 것 같다
	1. reconciliation을 부분적으로 적용하기
	2. reconciliation 구조를 유지하고 이전 상태를 기억할 수 있도록 하기

#### 리액트의 구조를 이해하고 본따서 만들어보자

- 고민 끝에 2번 방법으로 만들기로 결정했다. 기존 라이브러리의 구조가 리액트의 구조를 참고한 것이었기 때문에, 리액트에서 지역상태를 만들고 관리하는 방법을 이해하고 적용하는 것이 구조의 일관성을 가져갈 수 있을 것이라고 생각했다.
- 리액트 hook중에서 지금 필요한 useState의 동작원리를 이해하는 것에 집중했다. 상태값을 클로저로 가지고 관리한다는 것까지는 이해했는데, 다음 두 가지가 가장 큰 난관이었다.
	1. 컴포넌트 자체를 재생성할 때 상태를 초기화하지 않고 기존 값을 유지하는 것,
	2. 여러 개의 상태를 생성했을 때 컴포넌트의 기존 상태를 정확히 찾아서 매핑하는 것

#### 결과

- 결과적으로 상태를 변경하는 함수를 제공하고, 그 함수를 호출하면 내부적으로 reconciliation함수를 호출하여 렌더링하는 구조는 동일하다. 다만 state를 컴포넌트의 인스턴스가 가지면 재렌더링 시 이전 상태를 유지하는 것이 불가능하다고 생각되어, 상태를 관리하는 모듈을 분리하여 사용하게끔 만들었다.

- 문제 해결의 키워드는 크게 두가지였다.
	- 상태를 생성하는 함수인 useState가 매번 호출되니까, useState 바깥에 기존 상태를 저장하고 클로저로 참고하게 만들자
	- 앱을 여러 번 렌더링할 때 함수의 실행 순서가 동일하다는 것이 보장된다. 따라서 상태를 배열로 관리하면 인덱스를 이용하여 컴포넌트와 상태를 매핑해줄 수 있다.

```javascript

// state.js

const hooks = [];
let hookIdx = 0;

// useLocalState가 매번 새로 호출되기 때문에, 함수 바깥에 hooks 배열을 만들어서 상태 유지

const useLocalState = initialState => {
  // 기존 상태가 없을 경우에만 초기 상태 넣어주기
  hooks[hookIdx] = hooks[hookIdx] || initialState;

  const currentHookIdx = hookIdx;

  const setState = nextState => {
    hooks[currentHookIdx] = typeof nextState === 'function' ? nextState(hooks[currentHookIdx]) : nextState;
    //렌더링 이전에 인덱스를 초기화하여 상태들의 순서 유지
    hookIdx = 0;
    render();
  };

  hookIdx += 1;
  return [hooks[currentHookIdx], setState];
};

```

#### 아쉬운 점

##### 구조의 일관성이 떨어진다

- 처음에는 라이브러리 전체가 리액트의 구조를 본따서 만들었고, reconciliation 구조도 변경하지 않았기 때문에 일관성이 유지된다고 생각했다.
- 하지만 리액트의 컴포넌트는 크게 클래스형 / 함수형으로 나뉘는데, 우리의 라이브러리는 컴포넌트는 클래스형, 상태관리는 함수형이 되어버렸다.
- 구조의 일관성을 유지하려면 컴포넌트도 함수형으로 만들거나, 상태관리를 컴포넌트 클래스 안에서 해결하는 것이 맞는 것 같다.
- 프로젝트 일정이 너무 촉박해서 당장 수정하는 것은 어려울 것 같고, 기능 구현을 최대한 서둘러서 마무리한 뒤 마감 전에 꼭 다시 고쳐보고싶다.

- 참고문헌
	- https://www.netlify.com/blog/2019/03/11/deep-dive-how-do-react-hooks-really-work/