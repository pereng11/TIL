# 22/10/17

## 오늘 고민한 것들

### 컨벤션은 얼마나 구체적으로 맞춰야 할까?

#### 클래스 이름

- 클래스 이름을 고민하는 시간이 너무 길어서 CSS Module을 통해 해결하고자 했다. 하지만 스타일과 관계 없이 공통적인 요소를 묶거나, 요소에 특별한 이름이 필요한 경우에도 클래스를 줄 필요가 생겼다.
- CSS Module의 클래스 이름은 CSS 속성을 하나라도 줘야 정상 동작한다. 이름만 선언하고 어떤 속성도 넣지 않으면 undefined가 된다. 따라서 스타일을 줄 필요가 없는 요소들에 대해서는 CSS Module의 클래스 이름을 활용할 수가 없었다
- 최대한 이름 고민하는 시간을 줄이기 위해, 위와 같은 경우 클래스 이름은 일반 문자열로 단순하게 짓되 선택자로 사용할 때 다른 컴포넌트의 선택자와 겹치는 일이 없도록 해당 컴포넌트에 있는 CSS Module의 이름을 하나 이상 섞기로 했다.

### 구조의 일관성을 유지하기

#### 상태관리

- 어제 지역상태를 사용할 수 있도록 새로운 상태관리 구조를 도입하였다. 이제 기능 개발에 집중할 수 있겠다고 생각했는데, 이벤트 핸들러와 관련해 예상치 못한 문제가 발생했다.
- 기존에는 루트 컴포넌트를 재생성하지 않았기 때문에, 상태 또한 1번만 생성되어 이벤트 핸들러 동작에 문제가 없었다. 하지만 이번에 루트 컴포넌트까지 재렌더링하게 구조가 바뀌자, 이벤트 핸들러가 최신 상태를 참조하지 못하는 문제가 발생했다.
- this와 클로저가 합쳐진 문제였는데, 정리하자면 다음과 같다
	- 기존에는 루트 컴포넌트를 재생성하지 않았다. 즉, 루트에 존재하는 상태 객체의 참조가 변할 일이 없었다.
	- 기존에는 이벤트 핸들러를 중복검사를 통해 최초 1회만 등록하게 만들었다. 루트 컴포넌트와 달리 이벤트 핸들러를 등록하는 컴포넌트는 렌더링마다 재생산되며, 그때마다 핸들러를 등록하는 함수를 호출하기 때문이었다.

	- 하지만 지역 상태를 도입한 후 루트 컴포넌트까지 재생성되자, 최초 등록된 이벤트 핸들러가 최초 렌더링 때의 루트 컴포넌트만을 참조하는 문제가 발생했다.
	- 기본적으로 이벤트 핸들러 내부의 this는 event.currentTarget을 가리킨다. 이때 상태를 변경하는 함수를 정상적으로 실행하려면 this가 이벤트 타깃이 아닌 컴포넌트의 인스턴스를 가리켜야 한다.
	- 그렇기 때문에 이벤트 핸들러를 props으로 내려줄 때 bind(this)를 사용하여 현재 인스턴스로 this를 고정시켜 사용하고 있었다. 결국 매번 재생성되는 컴포넌트의 인스턴스가 상태를 최신으로 유지하는 것과 별개로, 이벤트 핸들러는 최초 바인딩한 인스턴스만을 참조할 수 있었다.

	- 고민 끝에 문제를 근본적으로 해결하기 위해서는 렌더링할 때마다 이벤트 핸들러를 새로 달아주어야 한다는 결론을 내렸다. 이벤트 핸들러를 한 번만 등록하면서 this 참조를 바꿔주는 것이 불가능했으며, 최신 상태를 가지고 있는 인스턴스를 참조하는 것이 논리적으로도 타당했기 때문이다.
	- 따라서 diff알고리즘을 수행하기 전에 기존에 기억하고 있는 이벤트 핸들러를 모두 지워주고, 핸들러를 담는 `handlersHolder` 배열을 초기화하였다. 그리고 루트 컴포넌트의 render를 호출하여 `handlersHolder`배열에 새로운 이벤트 핸들러 정보를 담고, render가 끝나면 해당 배열을 이용하여 새로운 이벤트 핸들러를 달아주는 것으로 해결하였다.

#### 다시 문제

- 상태 관리 함수로만 렌더링을 하는 경우에는 아무 문제가 없었